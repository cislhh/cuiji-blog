---
slug: frontend-performance-monitoring-optimization
title: å‰ç«¯æ€§èƒ½ç›‘æ§ä¸ç”¨æˆ·ä½“éªŒä¼˜åŒ–ä½“ç³»
date: 2025-02-18
authors: [cuiji]
tags: [performance, monitoring, core-web-vitals, optimization]
keywords: [æ€§èƒ½ç›‘æ§, Core Web Vitals, ç”¨æˆ·ä½“éªŒ, æ€§èƒ½ä¼˜åŒ–, å‰ç«¯ç›‘æ§]
---

åœ¨äº’è”ç½‘æ—¶ä»£ï¼Œç”¨æˆ·å¯¹ç½‘ç«™æ€§èƒ½çš„è¦æ±‚è¶Šæ¥è¶Šé«˜ã€‚ä¸€ä¸ªåŠ è½½ç¼“æ…¢çš„ç½‘ç«™ä¸ä»…ä¼šå½±å“ç”¨æˆ·ä½“éªŒï¼Œè¿˜ä¼šç›´æ¥å½±å“ä¸šåŠ¡æŒ‡æ ‡ï¼šé¡µé¢åŠ è½½æ—¶é—´æ¯å¢åŠ 1ç§’ï¼Œè½¬åŒ–ç‡å°±ä¼šä¸‹é™7%ã€‚

ä½†æ€§èƒ½ä¼˜åŒ–ä¸æ˜¯ç›²ç›®çš„ï¼Œæˆ‘ä»¬éœ€è¦å»ºç«‹å®Œæ•´çš„ç›‘æ§ä½“ç³»ï¼Œç”¨æ•°æ®é©±åŠ¨ä¼˜åŒ–å†³ç­–ã€‚æœ¬æ–‡å°†æ·±å…¥æ¢è®¨å¦‚ä½•æ„å»ºå‰ç«¯æ€§èƒ½ç›‘æ§ç³»ç»Ÿï¼Œä»¥åŠå¦‚ä½•åŸºäºç›‘æ§æ•°æ®ä¼˜åŒ–ç”¨æˆ·ä½“éªŒã€‚

---

## ä¸€ã€æ€§èƒ½ç›‘æ§çš„æ ¸å¿ƒæŒ‡æ ‡ï¼šCore Web Vitals

> ğŸ“Š æ ¸å¿ƒç†å¿µï¼šå¥½çš„æ€§èƒ½ç›‘æ§ä¸æ˜¯æµ‹é‡ä¸€åˆ‡ï¼Œè€Œæ˜¯æµ‹é‡ç”¨æˆ·çœŸæ­£å…³å¿ƒçš„æŒ‡æ ‡ã€‚

### ä»€ä¹ˆæ˜¯ Core Web Vitalsï¼Ÿ

Core Web Vitals æ˜¯ Google æå‡ºçš„ä¸‰ä¸ªå…³é”®ç”¨æˆ·ä½“éªŒæŒ‡æ ‡ï¼š

1. **LCP (Largest Contentful Paint)**ï¼šæœ€å¤§å†…å®¹ç»˜åˆ¶æ—¶é—´
2. **FID (First Input Delay)**ï¼šé¦–æ¬¡è¾“å…¥å»¶è¿Ÿ
3. **CLS (Cumulative Layout Shift)**ï¼šç´¯ç§¯å¸ƒå±€åç§»

### 1. LCP - æœ€å¤§å†…å®¹ç»˜åˆ¶æ—¶é—´

LCP æµ‹é‡é¡µé¢ä¸»è¦å†…å®¹åŠ è½½å®Œæˆçš„æ—¶é—´ã€‚

```javascript
// ç›‘æ§ LCP
function measureLCP() {
  const observer = new PerformanceObserver((list) => {
    const entries = list.getEntries()
    const lastEntry = entries[entries.length - 1]

    console.log('LCP:', lastEntry.startTime)

    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    sendMetric('lcp', lastEntry.startTime)
  })

  observer.observe({ entryTypes: ['largest-contentful-paint'] })
}

// é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹ç›‘æ§
window.addEventListener('load', measureLCP)
```

**LCP è¯„åˆ†æ ‡å‡†**ï¼š

- è‰¯å¥½ï¼šâ‰¤ 2.5 ç§’
- éœ€è¦æ”¹è¿›ï¼š2.5 - 4.0 ç§’
- å·®ï¼š> 4.0 ç§’

### 2. FID - é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ

FID æµ‹é‡ç”¨æˆ·é¦–æ¬¡ä¸é¡µé¢äº¤äº’æ—¶çš„å“åº”æ—¶é—´ã€‚

```javascript
// ç›‘æ§ FID
function measureFID() {
  const observer = new PerformanceObserver((list) => {
    const entries = list.getEntries()
    entries.forEach((entry) => {
      console.log('FID:', entry.processingStart - entry.startTime)

      // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
      sendMetric('fid', entry.processingStart - entry.startTime)
    })
  })

  observer.observe({ entryTypes: ['first-input'] })
}

// é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹ç›‘æ§
window.addEventListener('load', measureFID)
```

**FID è¯„åˆ†æ ‡å‡†**ï¼š

- è‰¯å¥½ï¼šâ‰¤ 100 æ¯«ç§’
- éœ€è¦æ”¹è¿›ï¼š100 - 300 æ¯«ç§’
- å·®ï¼š> 300 æ¯«ç§’

### 3. CLS - ç´¯ç§¯å¸ƒå±€åç§»

CLS æµ‹é‡é¡µé¢å¸ƒå±€çš„ç¨³å®šæ€§ã€‚

```javascript
// ç›‘æ§ CLS
function measureCLS() {
  let clsValue = 0
  let clsEntries = []

  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (!entry.hadRecentInput) {
        clsEntries.push(entry)
        clsValue += entry.value
      }
    }

    console.log('CLS:', clsValue)

    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    sendMetric('cls', clsValue)
  })

  observer.observe({ entryTypes: ['layout-shift'] })
}

// é¡µé¢åŠ è½½å®Œæˆåå¼€å§‹ç›‘æ§
window.addEventListener('load', measureCLS)
```

**CLS è¯„åˆ†æ ‡å‡†**ï¼š

- è‰¯å¥½ï¼šâ‰¤ 0.1
- éœ€è¦æ”¹è¿›ï¼š0.1 - 0.25
- å·®ï¼š> 0.25

---

## äºŒã€æ„å»ºæ€§èƒ½ç›‘æ§ç³»ç»Ÿ

### åŸºç¡€ç›‘æ§ç±»

```javascript
class PerformanceMonitor {
  constructor(config = {}) {
    this.config = {
      apiEndpoint: config.apiEndpoint || '/api/metrics',
      sampleRate: config.sampleRate || 1.0,
      debug: config.debug || false,
      ...config,
    }

    this.metrics = new Map()
    this.observers = []

    this.init()
  }

  init() {
    // ç›‘æ§é¡µé¢åŠ è½½æ€§èƒ½
    this.measurePageLoad()

    // ç›‘æ§ Core Web Vitals
    this.measureCoreWebVitals()

    // ç›‘æ§èµ„æºåŠ è½½æ€§èƒ½
    this.measureResourceTiming()

    // ç›‘æ§ç”¨æˆ·äº¤äº’æ€§èƒ½
    this.measureUserInteraction()
  }

  // æµ‹é‡é¡µé¢åŠ è½½æ€§èƒ½
  measurePageLoad() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0]

      const metrics = {
        // DNS æŸ¥è¯¢æ—¶é—´
        dns: navigation.domainLookupEnd - navigation.domainLookupStart,
        // TCP è¿æ¥æ—¶é—´
        tcp: navigation.connectEnd - navigation.connectStart,
        // è¯·æ±‚å“åº”æ—¶é—´
        request: navigation.responseEnd - navigation.requestStart,
        // DOM è§£ææ—¶é—´
        domParse: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        // é¡µé¢å®Œå…¨åŠ è½½æ—¶é—´
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        // æ€»åŠ è½½æ—¶é—´
        total: navigation.loadEventEnd - navigation.navigationStart,
      }

      this.sendMetrics('page-load', metrics)
    })
  }

  // æµ‹é‡ Core Web Vitals
  measureCoreWebVitals() {
    // LCP
    this.measureLCP()

    // FID
    this.measureFID()

    // CLS
    this.measureCLS()
  }

  measureLCP() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1]

      this.sendMetric('lcp', lastEntry.startTime)
    })

    observer.observe({ entryTypes: ['largest-contentful-paint'] })
    this.observers.push(observer)
  }

  measureFID() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      entries.forEach((entry) => {
        const fid = entry.processingStart - entry.startTime
        this.sendMetric('fid', fid)
      })
    })

    observer.observe({ entryTypes: ['first-input'] })
    this.observers.push(observer)
  }

  measureCLS() {
    let clsValue = 0

    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      }

      this.sendMetric('cls', clsValue)
    })

    observer.observe({ entryTypes: ['layout-shift'] })
    this.observers.push(observer)
  }

  // æµ‹é‡èµ„æºåŠ è½½æ€§èƒ½
  measureResourceTiming() {
    window.addEventListener('load', () => {
      const resources = performance.getEntriesByType('resource')

      resources.forEach((resource) => {
        const metrics = {
          name: resource.name,
          type: resource.initiatorType,
          duration: resource.duration,
          size: resource.transferSize,
          cached: resource.transferSize === 0,
        }

        this.sendMetrics('resource-timing', metrics)
      })
    })
  }

  // æµ‹é‡ç”¨æˆ·äº¤äº’æ€§èƒ½
  measureUserInteraction() {
    const events = ['click', 'keydown', 'scroll']

    events.forEach((eventType) => {
      document.addEventListener(eventType, (event) => {
        const startTime = performance.now()

        // ä½¿ç”¨ requestIdleCallback åœ¨ç©ºé—²æ—¶æµ‹é‡
        requestIdleCallback(() => {
          const endTime = performance.now()
          const duration = endTime - startTime

          this.sendMetric('user-interaction', {
            type: eventType,
            duration: duration,
            timestamp: Date.now(),
          })
        })
      })
    })
  }

  // å‘é€å•ä¸ªæŒ‡æ ‡
  sendMetric(name, value) {
    if (Math.random() > this.config.sampleRate) return

    const metric = {
      name,
      value,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
    }

    this.metrics.set(name, metric)

    if (this.config.debug) {
      console.log('Metric:', metric)
    }

    this.sendToServer(metric)
  }

  // å‘é€å¤šä¸ªæŒ‡æ ‡
  sendMetrics(name, metrics) {
    Object.entries(metrics).forEach(([key, value]) => {
      this.sendMetric(`${name}.${key}`, value)
    })
  }

  // å‘é€åˆ°æœåŠ¡å™¨
  async sendToServer(metric) {
    try {
      await fetch(this.config.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(metric),
      })
    } catch (error) {
      console.error('Failed to send metric:', error)
    }
  }

  // è·å–æ‰€æœ‰æŒ‡æ ‡
  getAllMetrics() {
    return Array.from(this.metrics.values())
  }

  // æ¸…ç†èµ„æº
  destroy() {
    this.observers.forEach((observer) => observer.disconnect())
    this.observers = []
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor({
  apiEndpoint: '/api/metrics',
  sampleRate: 0.1, // 10% é‡‡æ ·ç‡
  debug: true,
})
```

---

## ä¸‰ã€æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å›¾ç‰‡ä¼˜åŒ–

```javascript
// å›¾ç‰‡æ‡’åŠ è½½
class LazyImageLoader {
  constructor() {
    this.observer = new IntersectionObserver(this.handleIntersection.bind(this))
    this.images = document.querySelectorAll('img[data-src]')

    this.images.forEach((img) => this.observer.observe(img))
  }

  handleIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target
        this.loadImage(img)
        this.observer.unobserve(img)
      }
    })
  }

  loadImage(img) {
    const src = img.dataset.src
    const placeholder = img.src

    // åˆ›å»ºæ–°çš„å›¾ç‰‡å¯¹è±¡é¢„åŠ è½½
    const newImg = new Image()
    newImg.onload = () => {
      img.src = src
      img.classList.add('loaded')
    }
    newImg.onerror = () => {
      img.src = placeholder
      img.classList.add('error')
    }
    newImg.src = src
  }
}

// å›¾ç‰‡æ ¼å¼ä¼˜åŒ–
function optimizeImageFormat() {
  const images = document.querySelectorAll('img')

  images.forEach((img) => {
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    if (window.Modernizr && window.Modernizr.webp) {
      const src = img.src
      const webpSrc = src.replace(/\.(jpg|jpeg|png)$/i, '.webp')

      // é¢„åŠ è½½ WebP æ ¼å¼
      const webpImg = new Image()
      webpImg.onload = () => {
        img.src = webpSrc
      }
      webpImg.src = webpSrc
    }
  })
}
```

### 2. ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½

```javascript
// è·¯ç”±æ‡’åŠ è½½
const routes = {
  '/': () => import('./pages/Home.js'),
  '/about': () => import('./pages/About.js'),
  '/contact': () => import('./pages/Contact.js'),
}

// ç»„ä»¶æ‡’åŠ è½½
class LazyComponentLoader {
  constructor() {
    this.observer = new IntersectionObserver(this.handleIntersection.bind(this))
    this.components = document.querySelectorAll('[data-component]')

    this.components.forEach((component) => this.observer.observe(component))
  }

  async handleIntersection(entries) {
    for (const entry of entries) {
      if (entry.isIntersecting) {
        const component = entry.target
        const componentName = component.dataset.component

        try {
          const module = await import(`./components/${componentName}.js`)
          const ComponentClass = module.default

          const instance = new ComponentClass()
          component.appendChild(instance.render())

          this.observer.unobserve(component)
        } catch (error) {
          console.error(`Failed to load component ${componentName}:`, error)
        }
      }
    }
  }
}
```

### 3. ç¼“å­˜ç­–ç•¥

```javascript
// Service Worker ç¼“å­˜ç­–ç•¥
class CacheManager {
  constructor() {
    this.cacheName = 'app-cache-v1'
    this.cacheUrls = ['/', '/static/css/main.css', '/static/js/main.js', '/static/images/logo.png']
  }

  async install() {
    const cache = await caches.open(this.cacheName)
    await cache.addAll(this.cacheUrls)
  }

  async fetch(request) {
    const cache = await caches.open(this.cacheName)
    const cachedResponse = await cache.match(request)

    if (cachedResponse) {
      return cachedResponse
    }

    const networkResponse = await fetch(request)

    // ç¼“å­˜æˆåŠŸçš„å“åº”
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone())
    }

    return networkResponse
  }
}

// å†…å­˜ç¼“å­˜
class MemoryCache {
  constructor(maxSize = 100) {
    this.cache = new Map()
    this.maxSize = maxSize
  }

  get(key) {
    if (this.cache.has(key)) {
      // ç§»åŠ¨åˆ°æœ«å°¾ï¼ˆLRUï¼‰
      const value = this.cache.get(key)
      this.cache.delete(key)
      this.cache.set(key, value)
      return value
    }
    return null
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.maxSize) {
      // åˆ é™¤æœ€æ—§çš„é¡¹
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    this.cache.set(key, value)
  }
}
```

---

## å››ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 1. åŠ è½½çŠ¶æ€ç®¡ç†

```javascript
// åŠ è½½çŠ¶æ€ç»„ä»¶
class LoadingManager {
  constructor() {
    this.loadingStates = new Map()
    this.loadingOverlay = this.createLoadingOverlay()
  }

  createLoadingOverlay() {
    const overlay = document.createElement('div')
    overlay.className = 'loading-overlay'
    overlay.innerHTML = `
      <div class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">åŠ è½½ä¸­...</div>
      </div>
    `

    // æ·»åŠ æ ·å¼
    const style = document.createElement('style')
    style.textContent = `
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }
      .loading-spinner {
        text-align: center;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 16px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `
    document.head.appendChild(style)

    return overlay
  }

  showLoading(key = 'default') {
    this.loadingStates.set(key, true)
    document.body.appendChild(this.loadingOverlay)
  }

  hideLoading(key = 'default') {
    this.loadingStates.set(key, false)

    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–åŠ è½½çŠ¶æ€
    const hasLoading = Array.from(this.loadingStates.values()).some((state) => state)
    if (!hasLoading) {
      document.body.removeChild(this.loadingOverlay)
    }
  }

  isLoading(key = 'default') {
    return this.loadingStates.get(key) || false
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const loadingManager = new LoadingManager()

// å¼€å§‹åŠ è½½
loadingManager.showLoading('data')

// æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
fetch('/api/data')
  .then((response) => response.json())
  .then((data) => {
    // å¤„ç†æ•°æ®
    console.log(data)
  })
  .finally(() => {
    // ç»“æŸåŠ è½½
    loadingManager.hideLoading('data')
  })
```

### 2. é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶

```javascript
// é”™è¯¯å¤„ç†ä¸é‡è¯•
class ErrorHandler {
  constructor() {
    this.retryCount = 3
    this.retryDelay = 1000
  }

  async withRetry(fn, context = '') {
    let lastError

    for (let i = 0; i < this.retryCount; i++) {
      try {
        return await fn()
      } catch (error) {
        lastError = error
        console.warn(`${context} ç¬¬ ${i + 1} æ¬¡å°è¯•å¤±è´¥:`, error)

        if (i < this.retryCount - 1) {
          await this.delay(this.retryDelay * Math.pow(2, i)) // æŒ‡æ•°é€€é¿
        }
      }
    }

    throw new Error(`${context} é‡è¯• ${this.retryCount} æ¬¡åä»ç„¶å¤±è´¥: ${lastError.message}`)
  }

  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }

  // å…¨å±€é”™è¯¯å¤„ç†
  setupGlobalErrorHandling() {
    window.addEventListener('error', (event) => {
      this.handleError(event.error, 'JavaScript Error')
    })

    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(event.reason, 'Unhandled Promise Rejection')
    })
  }

  handleError(error, context) {
    console.error(`${context}:`, error)

    // å‘é€é”™è¯¯åˆ°ç›‘æ§ç³»ç»Ÿ
    this.sendErrorToMonitoring(error, context)

    // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯
    this.showUserFriendlyError()
  }

  sendErrorToMonitoring(error, context) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    fetch('/api/errors', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message: error.message,
        stack: error.stack,
        context,
        url: window.location.href,
        timestamp: Date.now(),
      }),
    })
  }

  showUserFriendlyError() {
    // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
    const errorDiv = document.createElement('div')
    errorDiv.className = 'error-message'
    errorDiv.innerHTML = `
      <div class="error-content">
        <h3>æŠ±æ­‰ï¼Œå‡ºç°äº†é”™è¯¯</h3>
        <p>è¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼Œæˆ–è”ç³»æŠ€æœ¯æ”¯æŒ</p>
        <button onclick="window.location.reload()">åˆ·æ–°é¡µé¢</button>
      </div>
    `

    document.body.appendChild(errorDiv)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const errorHandler = new ErrorHandler()
errorHandler.setupGlobalErrorHandling()

// å¸¦é‡è¯•çš„ API è°ƒç”¨
async function fetchDataWithRetry() {
  return await errorHandler.withRetry(async () => {
    const response = await fetch('/api/data')
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    return response.json()
  }, 'è·å–æ•°æ®')
}
```

---

## äº”ã€æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿

### å‰ç«¯ç›‘æ§é¢æ¿

```javascript
// æ€§èƒ½ç›‘æ§é¢æ¿
class PerformanceDashboard {
  constructor(container) {
    this.container = container
    this.metrics = new Map()
    this.charts = new Map()

    this.render()
    this.startRealTimeUpdates()
  }

  render() {
    this.container.innerHTML = `
      <div class="dashboard">
        <h2>æ€§èƒ½ç›‘æ§é¢æ¿</h2>
        
        <div class="metrics-grid">
          <div class="metric-card">
            <h3>é¡µé¢åŠ è½½æ—¶é—´</h3>
            <div class="metric-value" id="load-time">-</div>
            <div class="metric-trend" id="load-time-trend"></div>
          </div>
          
          <div class="metric-card">
            <h3>LCP</h3>
            <div class="metric-value" id="lcp">-</div>
            <div class="metric-trend" id="lcp-trend"></div>
          </div>
          
          <div class="metric-card">
            <h3>FID</h3>
            <div class="metric-value" id="fid">-</div>
            <div class="metric-trend" id="fid-trend"></div>
          </div>
          
          <div class="metric-card">
            <h3>CLS</h3>
            <div class="metric-value" id="cls">-</div>
            <div class="metric-trend" id="cls-trend"></div>
          </div>
        </div>
        
        <div class="charts-section">
          <div class="chart-container">
            <h3>æ€§èƒ½è¶‹åŠ¿</h3>
            <canvas id="performance-chart" width="800" height="400"></canvas>
          </div>
        </div>
      </div>
    `

    this.addStyles()
  }

  addStyles() {
    const style = document.createElement('style')
    style.textContent = `
      .dashboard {
        padding: 20px;
        font-family: Arial, sans-serif;
      }
      
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }
      
      .metric-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
      }
      
      .metric-value {
        font-size: 2em;
        font-weight: bold;
        color: #495057;
        margin: 10px 0;
      }
      
      .metric-trend {
        font-size: 0.9em;
        color: #6c757d;
      }
      
      .charts-section {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
      }
      
      .chart-container {
        text-align: center;
      }
      
      #performance-chart {
        max-width: 100%;
        height: auto;
      }
    `
    document.head.appendChild(style)
  }

  updateMetric(name, value) {
    const element = document.getElementById(name)
    if (element) {
      element.textContent = this.formatValue(name, value)
      element.className = `metric-value ${this.getPerformanceClass(name, value)}`
    }

    this.metrics.set(name, value)
    this.updateChart()
  }

  formatValue(name, value) {
    switch (name) {
      case 'load-time':
      case 'lcp':
      case 'fid':
        return `${value.toFixed(2)}ms`
      case 'cls':
        return value.toFixed(3)
      default:
        return value.toString()
    }
  }

  getPerformanceClass(name, value) {
    switch (name) {
      case 'load-time':
        return value < 2000 ? 'good' : value < 4000 ? 'warning' : 'bad'
      case 'lcp':
        return value < 2500 ? 'good' : value < 4000 ? 'warning' : 'bad'
      case 'fid':
        return value < 100 ? 'good' : value < 300 ? 'warning' : 'bad'
      case 'cls':
        return value < 0.1 ? 'good' : value < 0.25 ? 'warning' : 'bad'
      default:
        return 'good'
    }
  }

  updateChart() {
    const canvas = document.getElementById('performance-chart')
    const ctx = canvas.getContext('2d')

    // æ¸…ç©ºç”»å¸ƒ
    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // ç»˜åˆ¶ç®€å•çš„æŠ˜çº¿å›¾
    this.drawLineChart(ctx, canvas.width, canvas.height)
  }

  drawLineChart(ctx, width, height) {
    const data = Array.from(this.metrics.values())
    if (data.length < 2) return

    const padding = 40
    const chartWidth = width - 2 * padding
    const chartHeight = height - 2 * padding

    // ç»˜åˆ¶åæ ‡è½´
    ctx.strokeStyle = '#dee2e6'
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(padding, padding)
    ctx.lineTo(padding, height - padding)
    ctx.lineTo(width - padding, height - padding)
    ctx.stroke()

    // ç»˜åˆ¶æ•°æ®çº¿
    ctx.strokeStyle = '#3498db'
    ctx.lineWidth = 2
    ctx.beginPath()

    data.forEach((value, index) => {
      const x = padding + (index / (data.length - 1)) * chartWidth
      const y = height - padding - (value / Math.max(...data)) * chartHeight

      if (index === 0) {
        ctx.moveTo(x, y)
      } else {
        ctx.lineTo(x, y)
      }
    })

    ctx.stroke()
  }

  startRealTimeUpdates() {
    // æ¨¡æ‹Ÿå®æ—¶æ•°æ®æ›´æ–°
    setInterval(() => {
      // è¿™é‡Œåº”è¯¥ä»å®é™…çš„ç›‘æ§ç³»ç»Ÿè·å–æ•°æ®
      this.updateMetric('load-time', Math.random() * 3000 + 1000)
      this.updateMetric('lcp', Math.random() * 2000 + 1000)
      this.updateMetric('fid', Math.random() * 200 + 50)
      this.updateMetric('cls', Math.random() * 0.2)
    }, 5000)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const dashboard = new PerformanceDashboard(document.getElementById('dashboard'))
```

---

## å…­ã€å®é™…é¡¹ç›®ä¸­çš„æœ€ä½³å®è·µ

### 1. æ€§èƒ½é¢„ç®—

```javascript
// æ€§èƒ½é¢„ç®—é…ç½®
const performanceBudget = {
  lcp: 2500, // 2.5ç§’
  fid: 100, // 100æ¯«ç§’
  cls: 0.1, // 0.1
  loadTime: 3000, // 3ç§’
  bundleSize: 500000, // 500KB
}

// æ€§èƒ½é¢„ç®—æ£€æŸ¥
class PerformanceBudget {
  constructor(budget) {
    this.budget = budget
    this.violations = []
  }

  checkMetric(name, value) {
    if (value > this.budget[name]) {
      this.violations.push({
        metric: name,
        value: value,
        budget: this.budget[name],
        violation: value - this.budget[name],
      })

      console.warn(`æ€§èƒ½é¢„ç®—è¿å: ${name}`, {
        actual: value,
        budget: this.budget[name],
        violation: value - this.budget[name],
      })
    }
  }

  getViolations() {
    return this.violations
  }

  hasViolations() {
    return this.violations.length > 0
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const budget = new PerformanceBudget(performanceBudget)

// æ£€æŸ¥ LCP
budget.checkMetric('lcp', 3000) // è¿åé¢„ç®—

if (budget.hasViolations()) {
  console.log('æ€§èƒ½é¢„ç®—è¿å:', budget.getViolations())
}
```

### 2. è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•

```javascript
// è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•
class PerformanceTest {
  constructor() {
    this.results = []
  }

  async runTest(url, iterations = 5) {
    console.log(`å¼€å§‹æ€§èƒ½æµ‹è¯•: ${url}`)

    for (let i = 0; i < iterations; i++) {
      console.log(`ç¬¬ ${i + 1} æ¬¡æµ‹è¯•...`)

      const result = await this.measurePage(url)
      this.results.push(result)

      // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
      await this.delay(2000)
    }

    return this.analyzeResults()
  }

  async measurePage(url) {
    const page = await this.openPage(url)

    // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
    await page.waitForLoadState('networkidle')

    // æµ‹é‡æ€§èƒ½æŒ‡æ ‡
    const metrics = await page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0]
      return {
        loadTime: navigation.loadEventEnd - navigation.navigationStart,
        domContentLoaded:
          navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,
        firstContentfulPaint:
          performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0,
      }
    })

    await page.close()
    return metrics
  }

  analyzeResults() {
    const metrics = Object.keys(this.results[0])
    const analysis = {}

    metrics.forEach((metric) => {
      const values = this.results.map((r) => r[metric])
      analysis[metric] = {
        min: Math.min(...values),
        max: Math.max(...values),
        avg: values.reduce((a, b) => a + b, 0) / values.length,
        median: this.median(values),
      }
    })

    return analysis
  }

  median(values) {
    const sorted = values.sort((a, b) => a - b)
    const mid = Math.floor(sorted.length / 2)
    return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid]
  }

  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }
}
```

---

## ç»“è¯­

æ€§èƒ½ç›‘æ§ä¸æ˜¯ä¸€æ¬¡æ€§çš„å·¥ä½œï¼Œè€Œæ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ã€‚å»ºç«‹å®Œæ•´çš„ç›‘æ§ä½“ç³»éœ€è¦ï¼š

1. **æ˜ç¡®ç›®æ ‡**ï¼šç¡®å®šè¦ç›‘æ§çš„å…³é”®æŒ‡æ ‡
2. **å»ºç«‹åŸºçº¿**ï¼šäº†è§£å½“å‰æ€§èƒ½æ°´å¹³
3. **æŒç»­ç›‘æ§**ï¼šå®æ—¶è·Ÿè¸ªæ€§èƒ½å˜åŒ–
4. **å¿«é€Ÿå“åº”**ï¼šåŠæ—¶å¤„ç†æ€§èƒ½é—®é¢˜
5. **æŒç»­ä¼˜åŒ–**ï¼šåŸºäºæ•°æ®ä¸æ–­æ”¹è¿›

è®°ä½ï¼š**å¥½çš„æ€§èƒ½ç›‘æ§ç³»ç»Ÿä¸ä»…è¦èƒ½å‘ç°é—®é¢˜ï¼Œæ›´è¦èƒ½æŒ‡å¯¼ä¼˜åŒ–æ–¹å‘**ã€‚ç”¨æ•°æ®é©±åŠ¨å†³ç­–ï¼Œè®©ç”¨æˆ·ä½“éªŒæˆä¸ºäº§å“æˆåŠŸçš„å…³é”®å› ç´ ã€‚
